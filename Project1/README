# Προγραμματισμός Συστήματος - 1η Εργασία

Ονοματεπώνυμο: Βεργίνης Αριστοτέλης    


Οδηγίες Χρήσης:
###############
Για μεταγλώττιση: make

Για εκτέλεση: ./sniffer -p pathname  (π.χ. ./sniffer -p ../testfolder)

Για διαγραφή εκτελέσιμων: make clean

Ιδιαιτερότητες Υλοποίησης: 
##########################
Το πρόγραμμα υλοποιεί όλα τα ζητούμενα της εκφώνησης εκτός από την λειτουργία των workers να στέλνουν signal στον manager,
οτι τελείωσαν και είναι διαθέσιμοι να επεξεργαστούν νέο αρχείο. Αρα στην δικιά μου υλοποίηση ο κάθε worker επεξεργάζεται μονο ένα αρχείο και
όταν δημιουργηθεί νέο αρχείο στον φάκελο δημιουργείται νεος worker. Επίσης, τα .out αρχεία δημιουργούνται στον ίδιο φάκελο που παρακολουθεί
το inotifywait, έτσι για να δουλέψει το finder.sh πρέπει να τοποθετηθεί σε αυτό τον φάκελο.

!!! Δοκίμασα το πρόγραμμα στα μηχανήματα της σχολής και στην γραμμή 26 του αρχείου manager.cpp μου πετάει segmentation fault (core dumped).
Δεν μπορώ να εντοπίσω ποιό είναι το πρόβλημα, καθώς σε όποιο άλλο μηχάνμα linux το δοκίμασα δούλευε κανονικά. 

Λειτουργικότητα: 
################

-------manager.cpp--------

worker_info* worker_list::get_free_worker()
Στην συνάρτηση αυτή ελέγχουμε αν υπάρχει κάποιος διαθέσιμος worker στην λίστα worker_list.

void create_listener(char* dirname, int* fd)
Η συνάρτηση αυτη χρησιμεύει ώστε να δημιουργηθεί ο listener και να κληθεί μέσω execl η inotifywait και να παρακολουθεί τις αλλαγές που γίνονται στον φάκελο.

char* return_filename(char* path)
Στην συνάρτηση αυτή δίνεται ολόκληρο το path του φακέλου και επιστρέφει μονο το όνομα του.

void create_worker(char* fifo_name)
Καλεί τον worker με την execl.

void signal_handler(int sig)
Όταν δεχτούμε το signal Ctrl+C τότε γίνονται unlink τα named pipes.

int main(int argc, char** argv)
Αρχικά, στην main ελέγχουμε τα ορίσματα από την γραμμή εντολών και τα καταχωρούμε στις κατάλληλες μεταβλητές. Έπειτα, φτίαχνουμε το pipe και κάνουμε fork 
ώστε να δημιουργηθεί η διεργασία του listener και καλούμε την συνάρτηση create_listener(char* dirname, int* fd) στην οποία καλείται η inotifywait.
Αμέσως, μετά, σε μία ατέρμονη λούπα περιμένουμε να γίνει κάποια αλλαγή στο φάκελο που παρακολουθεί ο listener και όταν δημιουργηθεί κάποιο αρχείο στον
φάκελο αυτό ελέγχουμε αν υπάρχει κάποιος ελεύθερος worker. Αν υπάρχει κάποιος ελεύθερος worker αλλάζουμε την boolean μεταβλητή που δηλώνει οτι ο worker
δεν είναι διαθέσιμος και του περνάμε τα κατάλληλα στοιχεία μέσω του named pipe. Ωστόσο, αν δεν υπάρχει ελεύθερος worker δημιουργούμε ενα named pipe 
και καλουμε την συνάρτηση create_worker(char* fifo_name) η οποία με execl καλεί το πρόγραμμα worker. Τέλος, προσθέτουμε τα νέα στοιχεία του νέου worker
στην λίστα worker_list και του περνάμε τα κατάλληλα στοιχεία μέσω του named pipe.


-------worker.cpp--------

long int findSize(char filename[])
Στην συνάρτηση αυτή ανοίγουμε ένα αρχείο και βρίσκουμε το μέγεθός του.

int main(int argc, char** argv)
Αρχικά, στην main ελέγχουμε το ορίσμα που δεχόματσε απο τον manager το οποίο είναι το όνομα του fifo. Έπειτα, παίρνουμε το όνομα του αρχείου που 
θέλουμε να επεξεργαστούμε από το fifo και με την βοήθεια της findSize(char filename[]) βρίσκουμε το μέγεθος του αρχείου. Αμέσως, μετά αντιγράφουμε το
περιεχόμενο του αρχείου σε έναν buffer. Απομονώνουμε κάθε λέξη του αρχείου και με την strtok και ελέγχουμε με την strstr αν η λέξη αρχίζει με 
http:/www. ή http:/ έτσι ώστε να τις αποθηκεύσουμε σε ενα vector. Έπειτα, με την strtok αφαιρούμε οτι υπάρχει μετά την / και κρατάμε μόνο το domain.
Τέλος, κάνουμε map και υπολογίζουμε πόσες φορές υπάρχει το ίδιο domain και μετά εκυπώνουμε τα αποτελέσματα σε ένα νέο .out αρχείο.







